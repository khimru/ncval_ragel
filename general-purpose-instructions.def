# This file describes instructions from AMD64 Architecture Programmer’s Manual
#				 Volume 3: General-Purpose and System Instruction
#				 Chapter 3: General-Purpose Instruction Reference
#################################################################################
# Note: all 32bit exclusive instructions are in x86-32-instructions.def
#       all 64bit exclusive instructions are in x86-64-instructions.def
#################################################################################
# File format: three rows separated by commas.  Line describes one instruction.
################################################################################
# First column: instruction description.
#   Includes name of the instruction and arguments.
#
#   Arguments consist of two parts: argument type and argument size.
#
#      Possible argument types:
#	1: One (for instructions like "shr" or "rol")
#	a: Accumulator (%al/%ax/%eax/%rax depending on size).
#	b: A memory operand addressed by the %ds:(%[er]bx). See "xlat".
#	c: Implicit %ecx/%rcx (depending on size).
#	d: Implicit %edx/%rdx (depending on size).
#	i: Second immediate value encoded in the instruction.
#	o: I/O port in %dx (used in "in"/"out" instructions).
#	p: Accumulator pair (%dx:%ax/%edx:%eax/%rdx:%rax depending on size).
#	r: Register in opcode (low 3 bits plus rex.B).
#	E: General purpose register or memory operand specified by the r/m
#	   field of the ModRM byte.  For memory operands, the ModRM byte may
#	   be followed by a SIB byte to specify one of the indexed
#	   register-indirect addressing forms.
#	G: General purpose register specified by the reg field of ModRM.
#	I: Immediate value encoded in the instruction.
#	M: A memory operand specified by the {mod, r/m}field of the ModRM byte.
#	   ModRM.mod ≠ 11b.
#	O: The offset of an operand is encoded in the instruction. There is no
#	   ModRM byte in the instruction encoding. Indexed register-indirect
#	   addressing using the SIB byte is not supported
#	X: A memory operand addressed by the %ds:%[er]si registers. Used in
#	   string instructions.
#	Y: A memory operand addressed by the %es:%[er]di registers. Used in
#	   string instructions.
#      Possible sizes:
#	␀: A byte, word, doubleword, or quadword (in 64-bit mode),
#	   depending on the effective operand size.
#	b: A byte, irrespective of the effective operand size.
#	d: A doubleword (32bit), irrespective of the effective operand size.
#	p: A 32-bit or 48-bit far pointer, depending on the effective operand
#	   size.
#	q: A quadword (64bit), irrespective of the effective operand size.
#	r: Register size (32bit in 32bit mode, 64bit in 64bit mode).
#	s: A 6-byte or 10-byte pseudo-descriptor.
#	v: A word, doubleword, or quadword (in 64-bit mode), depending on
#	   the effective operand size.
#	w: A word, irrespective of the effective operand size.
#	y: A doubleword or quadword depending on effective operand size.
#	z: A word if the effective operand size is 16 bits, or a doubleword
#	   if the effective operand size is 32 or 64 bits.
#################################################################################
# Second column: instruction opcodes.
#   Includes all opcode bytes.  If first opcode bytes is 0x66, 0xf2, or 0xf3
#   then they can be moved before other prefixes (and will be moved before REX
#   prefix if it's allowed).  Should include opcode "bytes" /0, /1, ..., /7 if
#   part of the opcode is stored in ModRM byte.  Use "/s" to for segment register
#   operations.
#################################################################################
# Third column: additional instruction notes.
#   Different kind of notes for the instruction: untypical prefixes (for example
#   "lock" prefix or "rep" prefix), CPUID checks, etc.
#
#     Possible prefixes:
#	condrep: prefixes "repe" and "repne" are allowed for the instruction
#	lock: prefix "lock" is allowed for the instruction
#	rep: prefix "rep" is allowed for the instruction
#
#     Possible CPUID values:
#	Fn0000_0001_ECX_CMPXCHG16B: Fn0000_0001_ECX[CMPXCHG16B]
#	Fn0000_0001_ECX_Monitor: Fn0000_0001_ECX[Monitor]
#	Fn0000_0001_ECX_POPCNT: Fn0000_0001_ECX[POPCNT]
#	Fn0000_0001_ECX_SSE42: Fn0000_0001_ECX[SSE42]
#	Fn0000_0001_ECX_XSAVE: Fn0000_0001_ECX[XSAVE]
#	Fn0000_0001_EDX_X87: Fn0000_0001_EDX[x87]
#	Fn0000_0001_EDX_CLFSH: Fn0000_0001_EDX[CLFSH]
#	Fn0000_0001_EDX_CMOV: Fn0000_0001_EDX[CMOV] || Fn8000_0001_EDX[CMOV]
#	Fn0000_0001_EDX_CMPXCHG8B: Fn0000_0001_EDX[CMPXCHG8B] ||
#				   Fn8000_0001_EDX[CMPXCHG8B]
#	Fn0000_0001_EDX_MMX: Fn0000_0001_EDX[MMX]
#	Fn0000_0001_EDX_SFENCE: Fn0000_0001_EDX[SSE] ||
#				Fn8000_0001_EDX[MmxExt]
#	Fn0000_0001_EDX_SSE2: Fn0000_0001_EDX[SSE2]
#	Fn8000_0001_ECX_3DNowPrefetch: Fn8000_0001_ECX[3DNowPrefetch] ||
#				       Fn8000_0001_EDX[LM] ||
#				       Fn8000_0001_EDX[3DNow]
#	Fn8000_0001_ECX_LahfSahf: Fn8000_0001_ECX[LahfSahf]
#	Fn8000_0001_ECX_SVM: Fn8000_0001_ECX[SVM] && EFER.SVME
#	Fn8000_0001_ECX_SKINIT: (Fn8000_0001_ECX[SVM] && EFER.SVME) ||
#				Fn8000_0001_ECX[SKINIT]
#	Fn8000_0001_EDX_3DNow: Fn8000_0001_EDX[3DNow]
#	Fn8000_0001_EDX_RDTSCP: Fn8000_0001_EDX[RDTSCP]
#	Fn0000_0007_EBX_x0_BMI: Fn0000_0007_EBX_x0[BMI]
######## ADC ####################################################################
adc I a, 0x14, lock
adc I E, 0x80 /2, lock
adc Ib Ev, 0x83 /2, lock
adc G E, 0x10, lock
adc E G, 0x12, lock
######## ADD ####################################################################
add I a, 0x04, lock
add I E, 0x80 /0, lock
add Ib Ev, 0x83 /0, lock
add G E, 0x00, lock
add E G, 0x02, lock
######## AND ####################################################################
and I a, 0x24, lock
and I E, 0x80 /4, lock
and Ib Ev, 0x83 /4, lock
and G E, 0x20, lock
and E G, 0x22, lock
######## ANDN ###################################################################
#$:andn
######## BEXTR ##################################################################
#$:bextr
######## BLCFILL ################################################################
#$:blcfill
######## BLCI ###################################################################
#$:blci
######## BLCIC ##################################################################
#$:blcic
######## BLCMSK #################################################################
#$:blcmsk
######## BLCS ###################################################################
#$:blcs
######## BLSFILL ################################################################
#$:blsfill
######## BLSI ###################################################################
#$:blsi
######## BLSIC ##################################################################
#$:blsic
######## BLSMSK #################################################################
#$:blsmsk
######## BLSSR ##################################################################
#$:blsr
######## BSF ####################################################################
bsf Ev Gv, 0x0f 0xbc
######## BSR ####################################################################
bsr Ev Gv, 0x0f 0xbd
######## BSWAP ##################################################################
bswap ry, 0x0f 0xc8
######## BT #####################################################################
bt Gv Ev, 0x0f 0xa3
bt Ib Ev, 0x0f 0xba /4
######## BTC ####################################################################
btc Gv Ev, 0x0f 0xbb
btc Ib Ev, 0x0f 0xba /7
######## BTR ####################################################################
btr Gv Ev, 0x0f 0xb3
btr Ib Ev, 0x0f 0xba /6
######## BTS ####################################################################
bts Gv Ev, 0x0f 0xab
bts Ib Ev, 0x0f 0xba /5
######## CALL (Near) ############################################################
call Jz, 0xe8
# "call" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
callw Ew, 0x66 0xff /2
######## CALL (Far) #############################################################
# "lcall" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
lcallw Mp, 0x66 0xff /3
######## CBW/CWDE/CDQE ##########################################################
cbtw, data16 0x98
cwtl, 0x98
######## CWD/CDQ/CQO ############################################################
cltd, 0x99
cwtd, data16 0x99
######## CLC ####################################################################
clc, 0xf8
######## CLD ####################################################################
cld, 0xfc
######## CLFLUSH ################################################################
clflush Mb, 0x0f 0xae /7, Fn0000_0001_EDX_CLFSH
######## CMC ####################################################################
cmc, 0xf5
######## CMOVCC #################################################################
cmova Ev Gv, 0x0f 0x47, Fn0000_0001_EDX_CMOV
cmovae Ev Gv, 0x0f 0x43, Fn0000_0001_EDX_CMOV
cmovbe Ev Gv, 0x0f 0x46, Fn0000_0001_EDX_CMOV
cmovb Ev Gv, 0x0f 0x42, Fn0000_0001_EDX_CMOV
cmove Ev Gv, 0x0f 0x44, Fn0000_0001_EDX_CMOV
cmovg Ev Gv, 0x0f 0x4f, Fn0000_0001_EDX_CMOV
cmovge Ev Gv, 0x0f 0x4d, Fn0000_0001_EDX_CMOV
cmovle Ev Gv, 0x0f 0x4e, Fn0000_0001_EDX_CMOV
cmovl Ev Gv, 0x0f 0x4c, Fn0000_0001_EDX_CMOV
cmovne Ev Gv, 0x0f 0x45, Fn0000_0001_EDX_CMOV
cmovno Ev Gv, 0x0f 0x41, Fn0000_0001_EDX_CMOV
cmovnp Ev Gv, 0x0f 0x4b, Fn0000_0001_EDX_CMOV
cmovns Ev Gv, 0x0f 0x49, Fn0000_0001_EDX_CMOV
cmovo Ev Gv, 0x0f 0x40, Fn0000_0001_EDX_CMOV
cmovp Ev Gv, 0x0f 0x4a, Fn0000_0001_EDX_CMOV
cmovs Ev Gv, 0x0f 0x48, Fn0000_0001_EDX_CMOV
######## CMP ####################################################################
cmp I a, 0x3c
cmp I E, 0x80 /7
cmp Ib Ev, 0x83 /7
cmp G E, 0x38
cmp E G, 0x3a
######## CMPS/CMPSB/CMPSW/CMPSD/CMPSQ ###########################################
cmps Y X, 0xa6, condrep
######## CMPXCHG ################################################################
cmpxchg G E, 0x0f 0xb0, lock
######## CMPXCHG8B/CMPXCHG16B ###################################################
cmpxchg8b Mq, 0x0f 0xc7 /1, lock Fn0000_0001_EDX_CMPXCHG8B
######## CPUID ##################################################################
#:cpuid, 0x0f 0xa2
######## CRC32 ##################################################################
#:crc32 G E, 0xf2 0x0f 0x32 0xf0, Fn0000_0001_ECX_SSE42
######## DEC ####################################################################
dec E, 0xfe /1, lock
######## DIV ####################################################################
div E, 0xf6 /6
######## ENTER ##################################################################
enter iw Ib, 0xc8
######## IDIV ###################################################################
idiv E, 0xf6 /7
######## IMUL ###################################################################
imul E, 0xf6 /5
#:imul G E, 0x0f 0xaf
imul Ib Ev Gv, 0x6b
imul Iz Ev Gv, 0x69
######## IN #####################################################################
in Ib ab, 0xe4
in Ib az, 0xe5
in ob ab, 0xec
in oz az, 0xed
######## INC ####################################################################
inc E, 0xfe /0, lock
######## INS/INSB/INSW/INSD #####################################################
ins ob Yb, 0x6c, rep
ins oz Yz, 0x6d, rep
######## INT ####################################################################
int Ib, 0xcd
######## Jcc ####################################################################
ja Jb, 0x77
ja Jz, 0x0f 0x87
jae Jb, 0x73
jae Jz, 0x0f 0x83
jbe Jb, 0x76
jbe Jz, 0x0f 0x86
jb Jb, 0x72
jb Jz, 0x0f 0x82
je Jb, 0x74
je Jz, 0x0f 0x84
jg Jb, 0x7f
jg Jz, 0x0f 0x8f
jge Jb, 0x7d
jge Jz, 0x0f 0x8d
jle Jb, 0x7e
jle Jz, 0x0f 0x8e
jl Jb, 0x7c
jl Jz, 0x0f 0x8c
jne Jb, 0x75
jne Jz, 0x0f 0x85
jno Jb, 0x71
jno Jz, 0x0f 0x81
jnp Jb, 0x7b
jnp Jz, 0x0f 0x8b
jns Jb, 0x79
jns Jz, 0x0f 0x89
jo Jb, 0x70
jo Jz, 0x0f 0x80
jp Jb, 0x7a
jp Jz, 0x0f 0x8a
js Jb, 0x78
js Jz, 0x0f 0x88
######## JMP (Near) #############################################################
jmp Jz, 0xe9
jmp Jb, 0xeb
# "jmp" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
jmpw Ew, 0x66 0xff /4
######## JMP (Far) ##############################################################
# "ljmp" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
ljmpw Mp, 0x66 0xff /5
######## LDS/LES/LFS/LGS/LSS ####################################################
#:lfs Mp Gz, 0x0f 0xb4
#:lgs Mp Gz, 0x0f 0xb5
#:lss Mp Gz, 0x0f 0xb2
######## LEA ####################################################################
lea Mv Gv, 0x8d
######## LFENCE #################################################################
#:lfence, 0x0f 0xae 0xe8, Fn0000_0001_EDX_SSE2
######## LLWPCB #################################################################
#$:llwpcb
######## LODS/LODSB/LODSW/LODSD/LODSQ ###########################################
lods X a, 0xac
######## LOOP/LOOPE/LOOPNE/LOOPNZ/LOOPZ #########################################
loop Jb, 0xe2
loope Jb, 0xe1
loopne Jb, 0xe0
######## LWPINS #################################################################
#$:lwpins
######## LWPVAL #################################################################
#$:lwpval
######## LZCNT ##################################################################
#:lzcnt Ev Gv, 0xf3 0x0f 0xbd, Fn0000_0007_EBX_x0_BMI
######## MFENCE #################################################################
#:mfence, 0x0f 0xae 0xf0, Fn0000_0001_EDX_SSE2
######## MOV ####################################################################
mov G E, 0x88
mov E G, 0x8a
mov Sw Mw, 0x8c /s
mov Sw Rv, 0x8c /s
mov Ew Sw, 0x8e /s
mov Ib rb, 0xb0
mov Iv rv, 0xb8
mov I E, 0xc6 /0
######## MOVD ###################################################################
#:movd Ey Vy, 0x66 0x0f 0x6e, Fn0000_0001_EDX_SSE2
#:movd Vy Ey, 0x66 0x0f 0x7e, Fn0000_0001_EDX_SSE2
#:movd Ey Py, 0x0f 0x6e, Fn0000_0001_EDX_MMX
#:movd Py Ey, 0x0f 0x7e, Fn0000_0001_EDX_MMX
######## MOVMSKPD ###############################################################
#:movmskpd Upd Gd, 0x66 0x0f 0x50, Fn0000_0001_EDX_SSE2
######## MOVMSKPS ###############################################################
#:movmskps Ups Gd, 0x0f 0x50, Fn0000_0001_EDX_SSE2
######## MOVNTI #################################################################
#:movnti Gy My, 0x0f 0xc3, Fn0000_0001_EDX_SSE2
######## MOVS/MOVSB/MOVSW/MOVSD/MOVSQ ###########################################
movs X Y, 0xa4, rep
######## MOVSX ##################################################################
#:movsx Eb Ev, 0x0f 0xbe
#:movsx Ew Ey, 0x0f 0xbf
######## MOVZX ##################################################################
#:movzx Eb Ev, 0x0f 0xb6
#:movzx Ew Ey, 0x0f 0xb7
######## MUL ####################################################################
mul E, 0xf6 /4
######## NEG ####################################################################
neg E, 0xf6 /3, lock
######## NOP ####################################################################
nop, 0x90
#:nop, 0x0f 0x1f /0
######## NOT ####################################################################
not E, 0xf6 /2, lock
######## OR #####################################################################
or I a, 0x0c, lock
or I E, 0x80 /1, lock
or Ib Ev, 0x83 /1, lock
or G E, 0x08, lock
or E G, 0x0a, lock
######## OUT ####################################################################
out ab Ib, 0xe6
out az Ib, 0xe7
out ab ob, 0xee
out az oz, 0xef
######## OUTS/OUTSB/OUTSW/OUTSD #################################################
outs Xb ob, 0x6e, rep
outs Xz oz, 0x6f, rep
######## PAUSE ##################################################################
#:pause, 0xf3 0x90
######## POP ####################################################################
# "pop" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
pop Ew, 0x66 0x8f /0
pop rr, 0x58
#:pop %fs, 0x0f 0xa1
#:pop %gs, 0x0f 0xa9
######## POPCNT #################################################################
#:popcnt Ev Gv, 0xf3 0x0f 0xb8, Fn0000_0001_ECX_POPCNT
######## POPF/POPFD/POPFQ #######################################################
popfw, data16 0x9d
######## PREFETCH/PREFETCHW #####################################################
prefetch Mb, 0x0f 0x0d /0, Fn8000_0001_ECX_3DNowPrefetch
prefetchw Mb, 0x0f 0x0d /1, Fn8000_0001_ECX_3DNowPrefetch
######## PREFETCHlevel ##########################################################
#:prefetchnta Mb, 0x0f 0x18 /0
#:prefetch0 Mb, 0x0f 0x18 /1
#:prefetch1 Mb, 0x0f 0x18 /2
#:prefetch2 Mb, 0x0f 0x18 /3
######## PUSH ###################################################################
# "push" does not require rex prefix and always uses 64bit addresses in x86-64
# mode unless data16 prefix is used.  We use simple solution: 16bit call is
# declared as common for 32bit/64bit mode and 32bit/64bit versions are described
# in the appropriate files.
push Ew, 0x66 0xff /6
push rr, 0x50
push Iz, 0x68
push Ib, 0x6a
#:pop %fs, 0x0f 0xa0
#:pop %gs, 0x0f 0xa8
######## PUSHF/PUSHFD/PUSHFQ ####################################################
pushfw, data16 0x9c
######## RCL ####################################################################
rcl E, 0xd0 /2
rcl cb E, 0xd2 /2
rcl Ib E, 0xc0 /2
######## RCR ####################################################################
rcr E, 0xd0 /3
rcr cb E, 0xd2 /3
rcr Ib E, 0xc0 /3
######## RET (Near) #############################################################
ret Iw, 0xc2
######## RET (Far) ##############################################################
lret, 0xcb
lret Iw, 0xca
######## ROL ####################################################################
rol E, 0xd0 /0
rol cb E, 0xd2 /0
rol Ib E, 0xc0 /0
######## ROR ####################################################################
ror Ib E, 0xc0 /1
ror E, 0xd0 /1
ror cb E, 0xd2 /1
######## SAL ####################################################################
# AMD manual claims this opcode works identically to shl.  Intel manual
# says it's reserved.  Objdump does not like it.
# sal E, 0xd0 /6
# sal cb E, 0xd2 /6
# sal Ib E, 0xc0 /6
######## SAL/SHL ################################################################
shl E, 0xd0 /4
shl cb E, 0xd2 /4
shl Ib E, 0xc0 /4
######## SAR ####################################################################
sar Ib E, 0xc0 /7
sar E, 0xd0 /7
sar cb E, 0xd2 /7
######## SBB ####################################################################
sbb I a, 0x1c, lock
sbb I E, 0x80 /3, lock
sbb Ib Ev, 0x83 /3, lock
sbb G E, 0x18, lock
sbb E G, 0x1a, lock
######## SCAS/SCASB/SCASW/SCASD/SCASQ ###########################################
scas Y a, 0xae
######## SETcc ##################################################################
seta Eb, 0x0f 0x97, Fn0000_0001_EDX_CMOV
setae Eb, 0x0f 0x93, Fn0000_0001_EDX_CMOV
setbe Eb, 0x0f 0x96, Fn0000_0001_EDX_CMOV
setb Eb, 0x0f 0x92, Fn0000_0001_EDX_CMOV
sete Eb, 0x0f 0x94, Fn0000_0001_EDX_CMOV
setg Eb, 0x0f 0x9f, Fn0000_0001_EDX_CMOV
setge Eb, 0x0f 0x9d, Fn0000_0001_EDX_CMOV
setle Eb, 0x0f 0x9e, Fn0000_0001_EDX_CMOV
setl Eb, 0x0f 0x9c, Fn0000_0001_EDX_CMOV
setne Eb, 0x0f 0x95, Fn0000_0001_EDX_CMOV
setno Eb, 0x0f 0x91, Fn0000_0001_EDX_CMOV
setnp Eb, 0x0f 0x9b, Fn0000_0001_EDX_CMOV
setns Eb, 0x0f 0x99, Fn0000_0001_EDX_CMOV
seto Eb, 0x0f 0x90, Fn0000_0001_EDX_CMOV
setp Eb, 0x0f 0x9a, Fn0000_0001_EDX_CMOV
sets Eb, 0x0f 0x98, Fn0000_0001_EDX_CMOV
######## SFENCE #################################################################
#:sfence, 0x0f 0ae 0xf8, Fn0000_0001_EDX_SFENCE
######## SHLD ###################################################################
#:shld Ib Gv Ev, 0x0f 0xa4
#:shld cb Gv Ev, 0x0f 0xa5
######## SHR ####################################################################
shr E, 0xd0 /5
shr cb E, 0xd2 /5
shr Ib E, 0xc0 /5
######## SHRD ###################################################################
#:shrd Ib Gv Ev, 0x0f 0xac
#:shrd cb Gv Ev, 0x0f 0xad
######## SLWPCB #################################################################
#$:slwpcb
######## STC ####################################################################
stc, 0xf9
######## STD ####################################################################
std, 0xfd
######## STOS/STOSB/STOSW/STOSD/STOSQ ###########################################
stos a Y, 0xaa
######## SUB ####################################################################
sub I a, 0x2c, lock
sub I E, 0x80 /5, lock
sub Ib Ev, 0x83 /5, lock
sub G E, 0x28, lock
sub E G, 0x2a, lock
######## T1MSK ##################################################################
#$:tsmsk
######## TEST ###################################################################
test I a, 0xa8
test I E, 0xf6 /0
# AMD manual claims this opcode works identically to /0.  Intel manual
# says it's reserved.  Objdump does not like it.
# test I E, 0xf6 /1
test G E, 0x84
######## TZCNT ##################################################################
#:tzcnt Ev Gv, 0xf3 0x0f 0xbc, Fn0000_0007_EBX_x0_BMI
######## TZMSK ##################################################################
#$:tzmsk
######## XADD ###################################################################
#:xadd G E, 0x0f 0xc0, lock
######## XCHG ###################################################################
xchg av rv, 0x90
xchg G E, 0x86, lock
######## XLAT ###################################################################
xlat bb, 0xd7
######## XOR ####################################################################
xor I a, 0x34, lock
xor I E, 0x80 /6, lock
xor Ib Ev, 0x83 /6, lock
xor G E, 0x30, lock
xor E G, 0x32, lock
#################################################################################
